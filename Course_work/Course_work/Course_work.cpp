#include "pch.h"
#include <iostream>
#include <vector>
#include <fstream>   // библиотека для использования файловых потоков
#include "Product.h"
#include "Verification_functions.h"
#include "SkladOptions.h"

using namespace std;

int main()
{
	setlocale(LC_ALL, "Russian");
	vector <Product> sklad; // "векторный" массив структур(товаров)
	Product buffer;			// буфер, через который будем заполнять массив
	string fileName;		// переменная будет хранить названия файлов
	bool flag = false;		// индикатор ошибки открытия/записи/чтения файла
	int choice;				// переменная выбора действий интерфейса

	cout << "Варианты действий:\n"  // выбор действий
		<< "1. Добавить товары заново\n"
		<< "2. Хотите открыть существующую базу\n"
		<< "Выберете желаемый вариант: ";
	choice = Enter_choice(2);       // ввод варианта через функцию с проверкой


	if (choice == 2)  // если хочешь открыть существующую базу
	{
		ifstream fin; // открываем поток считывания с файла

		fin.open("Names.txt"); // открываем файл в котором хранятся названия товаров
		if (!fin.is_open())    // если файл не открыт, то его не существует
		{
		emptyFile: // метка от перехода, если файл "Names.txt" пуст
			cout << "\nСуществующей базы данных не найдено!\n" // выводим предупреждение
				<< "1. Добавить товары заново\n"
				<< "2. Закрыть программу\n"
				<< "Выберете желаемый вариант: "; // делаем выбор
			choice = Enter_choice(2); // ввод варианта через функцию с проверкой

			if (choice == 1) // если хотим добавить товары заново
				goto Enter;  // то переходим по метке к "добавлению"
			else             // если хотим закрыть программу
				return 0;    // то завершаем
		}
		else   // если файл "Names.txt" с названиями товаров открылся
		{
			while (!fin.eof()) // пока файл имен не закончится
			{
				getline(fin, buffer.name); // считываем названия товаров/файлов
				sklad.push_back(buffer);   // добавляем считанное название в новый элемент массива
			}
		}
		fin.close(); // закрываем файл в котором хранятся названия товаров
		// проверка на пустоту файла названий "Names.txt", если файл пуст, то нет базы данных
		if (sklad[0].name == "") // если первое название "пустое", то и файл пуст
		{
			remove("Names.txt"); // удаляем файл названий "Names.txt"
			sklad.erase(sklad.begin()); //удаляем элемент массива который заполнен пустым названием
			goto emptyFile; // переход к части кода "Базы данных не существует"
		}

		for (int i = 0; i < sklad.size(); i++) // цикл от первого до последнего товара в массиве товаров
		{
			fin.open(sklad[i].name + ".txt"); // открываем файл с названием считанным из файла
			if (!fin.is_open()) // если файл не открылся
			{
				flag = true; // установить индикатор "true"
			}
			else // если файл открылся
			{
				fin >> sklad[i].artikul; // считываем артикул товара
				fin >> sklad[i].price;   // считываем цену товара
				fin >> sklad[i].volume;  // считываем кол-во товара
			}
			fin.close(); // закрываем файл с названием считанным из файла
		}

		if (flag) // если флаг "true", значит  ошибка
		{
			cout << "\nОшибка считывания данных!\n"; // выводим предупреждение об ошибке
			return 0; // завершить программу
		}
		else // если флаг "false", значит успех
		{
			cout << "\nДанные успешно считались!\n"; // выводим информацию об успехе

			/*УДАЛЯЕМ ВСЕ ФАЙЛЫ*/
			if (remove("Names.txt") != 0) // удаляем файл названий "Names.txt"
				flag = true;              // если файл не удален делаем флаг "true"

			for (int i = 0; i < sklad.size(); i++) // цикл по всему массиву товаров
			{
				fileName = sklad[i].name + ".txt"; // записываем название файла исходя из названия товара
				char fileName_char[101];                       // преобразование из string в char
				strcpy_s(fileName_char, fileName.c_str());     // тк remove не работает со string
				if (remove(fileName_char) != 0)                // удаляем файлы товаров
					flag = true; // если файл не удален делаем флаг "true"
			}

			if (flag) // если флаг "true"
			{
				cout << "Ошибка!"; // выводим ошибку
				return 0;          // завершаем программу
			}
		}
	}


	if (choice == 1) // если добавляем товары заново
	{
		ifstream fin; // открываем поток считывания

		fin.open("Names.txt"); // открываем файл имен
		if (!fin.is_open()) // если файл не открыт, значит его нет
		{
			goto Enter; // тогда переходим к добавлению
		}
		else // если файл открыт
		{
			while (!fin.eof()) // пока файл названий "Names.txt" не закончился
			{
				getline(fin, buffer.name); // считываем названия в буфер
				sklad.push_back(buffer);   // добавляем буфер в элемент массива
			}

			for (int i = 0; i < sklad.size(); i++) // в цикле по всем товарам удаляем их
			{
				fileName = sklad[i].name + ".txt";              // записываем название файла исходя из названия товара
				char fileName_char[101];                        //преобразование из string в char
				strcpy_s(fileName_char, fileName.c_str());      // тк remove не работает со string
				remove(fileName_char);                          // удаляем файл
			}
		}
		fin.close(); // закрываем файл имен "Names.txt"

		remove("Names.txt");                        // удаляем файл имен "Names.txt"
		for (int i = sklad.size() - 1; i >= 0; i--) // в цикле от последнего до первого товара в массиве
			sklad.erase(sklad.begin() + i);         // удаляем элементы из массива(товары)
	}

	/*ВВОД СПИСКА ТОВАРОВ*/
	while (choice == 1) // пока хотим добавить новые товары
	{
	Enter: // метка на ввод данных

		buffer.set_info(); //Вводим информацию о товаре в буфер
		sklad.push_back(buffer); // добавляем новый элемент массива и записываем в него буфер


		cout << "\nХотите добавить новый товар на склад?\n" // добавлять ли товар?
			<< "1. Да\n"
			<< "2. Нет\n"
			<< "Выберете желаемый вариант: ";
		choice = Enter_choice(2); // вводим вариант через функцию с проверкой
	}

	/*После ввода*/
	if (choice == 2) // если товары больше не добавляем
	{
		output_spisok(sklad, sklad.size()); //вывод списка товаров

		/*ОПЦИИ*/
	options: // метка на выбор опций
		cout << "\nСписок дальнейших действий:\n" //вывод возможных опций
			<< "1. Внести изменения\n"
			<< "2. Сортировать товары\n"
			<< "3. Добавить товар\n"
			<< "4. Удалить товар\n"
			<< "5. Поиск товара по названию\n"
			<< "6. Cохранить данные и выйти\n"
			<< "Выберете желаемый вариант: ";
		choice = Enter_choice(6); // вводим вариант через функцию с проверкой

		switch (choice) // выбор опции в зависимости от выбранной
		{
		case 1:
		{
			change(sklad, sklad.size()); // изменения товара
			cout << "\nИзмнения совершены!";
			output_spisok(sklad, sklad.size()); // вывод списка товаров
			
			//ПРОВЕРКА (продолжить/завершить)
			cout << "\nВыберете дальнейшее действие:\n"
				<< "1. Продолжить работу\n"
				<< "2. Cохранить данные и выйти\n"
				<< "Введите номер выбранного варианта: ";
			choice = Enter_choice(2); // вводим вариант через функцию с проверкой

			if (choice == 1)  // если продолжить работу
				goto options; // то переходим к выбору опций
			else              // если выход из программы
				goto escape;  // то переход к сохранению
		}
		break;

		case 2:
		{
			sort(sklad, sklad.size()); //сортировка товара

			cout << "\nСписок отсортированных товаров:" << endl;
			output_spisok(sklad, sklad.size()); // вывод списка товаров

			/*ПРОВЕРКА (продолжить/завершить)*/
			cout << "\nВыберете дальнейшее действие:\n"
				<< "1. Продолжить работу\n"
				<< "2. Cохранить данные и выйти\n"
				<< "Введите номер выбранного варианта: ";
			choice = Enter_choice(2); // вводим вариант через функцию с проверкой

			if (choice == 1)  // если продолжить работу
				goto options; // то переходим к выбору опций
			else              // если выход из программы
				goto escape;  // то переход к сохранению
		}
		break;

		case 3:
		{
			goto Enter; // переход по метке для добавления товара (в начало)
		}
		break;

		case 4:
		{
			/*int *number = new int; // номер товара
			cout << "\nВведите номер товара, который хотите удалить: ";
			*number = Enter_number(sklad.size());     // ввод номера товара через функцию с проверкой
			sklad.erase(sklad.begin() + *number - 1); // удаляем элемент массива с данным номером(номер - 1)*/

			delete_sklad_i(sklad, sklad.size());
			cout << "\nТовар удален!" << endl;
			output_spisok(sklad, sklad.size()); // вывод списка товаров

			/*ПРОВЕРКА (продолжить/завершить)*/
			cout << "\nВыберете дальнейшее действие:\n"
				<< "1. Продолжить работу\n"
				<< "2. Cохранить данные и выйти\n"
				<< "Введите номер выбранного варианта: ";
			choice = Enter_choice(2); // вводим вариант через функцию с проверкой

			if (choice == 1)  // если продолжить работу
				goto options; // то переходим к выбору опций
			else              // если выход из программы
				goto escape;  // то переход к сохранению
		}
		break;

		case 5:
		{
			
			search(sklad, sklad.size()); //поиск по имени

			/*ПРОВЕРКА (продолжить/завершить)*/
			cout << "\nВыберете дальнейшее действие:\n"
				<< "1. Продолжить работу\n"
				<< "2. Cохранить данные и выйти\n"
				<< "Введите номер выбранного варианта: ";
			choice = Enter_choice(2); // вводим вариант через функцию с проверкой

			if (choice == 1)  // если продолжить работу
				goto options; // то переходим к выбору опций
			else              // если выход из программы
				goto escape;  // то переход к сохранению
		}
		break;

		case 6:
		{
		escape:                        // метка на сохранение
			save(sklad, sklad.size()); //сохранение/запись в файл
		}
		break;

		default:
			break;
		}
	}
}
